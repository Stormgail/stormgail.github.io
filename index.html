<!DOCTYPE html>
<html>
<head>
<script>
"use strict";
function byId(e){return document.getElementById(e);}
function newEl(tag){return document.createElement(tag);}

window.addEventListener('load', onDocLoaded, false);

var grid = {};

var unrevealed = 0;
var empty = -2;
var metal = -1;
var fox = 1;
var medium = 2;
var swords = 3;

var foxValue = 100;
var mediumvalue = 15;
var chestvalue = 20;
var presentvalue = 10;
var swordsvalue = 5;

var nCols = 6;
var nRows = 6;

var positive = 1;
var negative = -1

var wantRetelling = false;

var swordFound = false;
var mediumFound = false;

var hasErrors = true;


var values = [
    {name:"Unrevealed",
    value: unrevealed},
    {name:"Empty",
    value: empty}
    ,
    {name:"Metal",
    value: metal}
    ,
    {name:"Fox",
    value: fox}
    ,
    {name:"Chest/Present",
    value: medium}
    ,
    {name:"Swords",
    value: swords}
]

function onDocLoaded()
{
    buildGrid();
    recalculateGrid();
}

function withinBounds(x,y)
{
if(x>=0 && y>=0 && x<=(nCols-1) && y<=(nRows-1)){
    return true
}
return false;
}

function canPlace(type, tile, onlyExactMatch){
    if (tile.type == type || (tile.type == unrevealed && !onlyExactMatch)){
        return true;
    }
    else
    {
        return false;
    }
}

function tryFitTiles(xStart,yStart){
    if(!mediumFound && tryFitMedium(xStart,yStart)){
        scoreMedium(xStart,yStart)
    }
    if(!swordFound){
        if(tryFitLongSide(xStart,yStart)){
            scoreLongSide(xStart,yStart);
        }
        if(tryFitLongTall(xStart,yStart)){
            scoreLongTall(xStart,yStart);
        }

    }
}


function tryFitMedium(xStart,yStart)
{
    return tryFitMedium(xStart,yStart,false)
}


function tryFitMedium(xStart,yStart,onlyExactMatch)
{
    return canFit(xStart,yStart,1,1,medium,onlyExactMatch)
}

function scoreMedium(xStart,yStart){
    addValueToTiles(xStart,yStart,1,1,4)
}


function tryFitLongSide(xStart,yStart)
{
    return tryFitLongSide(xStart,yStart,false)
}


function tryFitLongSide(xStart,yStart,onlyExactMatch)
{
    return canFit(xStart,yStart,2,1,swords,onlyExactMatch);
}

function scoreLongSide(xStart,yStart){
    
    addValueToTiles(xStart,yStart,2,1,6);
}

function tryFitLongTall(xStart,yStart)
{
    return tryFitLongTall(xStart,yStart,false);
}


function tryFitLongTall(xStart,yStart,onlyExactMatch)
{
    return canFit(xStart,yStart,1,2,swords,onlyExactMatch);
}

function scoreLongTall(xStart,yStart){
    addValueToTiles(xStart,yStart,1,2,6);
}



function canFit(xStart, yStart, xSize,ySize, type)
{
   return canFit(xStart, yStart, xSize,ySize, type, false)
}


function canFit(xStart, yStart, xSize,ySize, type, onlyExactMatch)
{
    var canPlaceTile = true;

    if(!withinBounds((xStart+xSize),(yStart+ySize))){
        return false;
    }

    var x, y;
    for (y=0; y<=ySize; y++)
    {

        for (x=0; x<=xSize; x++)
        {

            var currentXPos = xStart + x;
            var currentYPos =  yStart + y;
            
            var tile = grid[formatGridPosition(currentXPos,currentYPos)]
            
            canPlaceTile = canPlace(type,tile,onlyExactMatch);

            if(!canPlaceTile){
                return false;
            }
        }

    }  

    return canPlaceTile;
}

function addValueToTiles(xStart, yStart, xSize,ySize,valueToAdd)
{

    var x, y;
    for (y=0; y<=ySize; y++)
    {

        for (x=0; x<=xSize; x++)
        {

            var currentXPos = xStart + x;
            var currentYPos =  yStart + y;
            
            var tile = grid[formatGridPosition(currentXPos,currentYPos)]
            
           tile.value+= valueToAdd;
        }

    }  

}

function recalculateGrid(){
    clearGridValuesSection()
    validateGrid();

    if(!hasErrors){

    var x, y;
    for (y=0; y<nRows; y++)
    {
        for (x=0; x<nCols; x++)
        {
            tryFitTiles(x,y)
        }

    }

    buildGridValuesSection();
    }
}

function formatGridPosition(xpos,ypos){

return xpos + "/" + ypos;
}


function onGridValueChanged(evt)
{
    grid[this.name].type = this.value;

    recalculateGrid();
}


function clearGridValuesSection()
{
    byId('tblDebug').innerHTML = '';
}

function buildGridValuesSection()
{
    clearGridValuesSection();


    var tbl, curRow, curCell;
    tbl = newEl('table');
    var x, y;
    for (y=0; y<nRows; y++)
    {
        curRow = newEl('tr');
        tbl.appendChild(curRow);

        for (x=0; x<nCols; x++)
        {
            curCell = newEl('INPUT');       
            curCell.setAttribute("type", "text");
            curCell.value =  grid[formatGridPosition(x,y)].value
            curRow.appendChild(curCell);
        }
    }
    byId('tblDebug').appendChild(tbl);
}


function validateGrid()
{
    clearErrors();
    //Reset values
    hasErrors = false;
    swordFound = false;
    mediumFound = false;


    var swordCount = 0;
    var mediumCount = 0;

    var firstSword;

    var firstMedium;

    var x, y;
    for (y=0; y<nRows; y++)
    {     

        for (x=0; x<nCols; x++)
        {
            var tile = grid[formatGridPosition(x,y)];
            if(tile.type == swords){
                if(!firstSword){
                    firstSword = tile;
                }
                swordCount++
            }else if(tile.type == medium){
                
                if(!firstMedium){
                    firstMedium = tile;
                }

                mediumCount++
            }

            tile.value = 0;
        }
    }

    if(mediumCount<4 && mediumCount > 0){
        addError("If you have Found one medium tile, please fill in the rest.")
    }

    if(swordCount<6  && swordCount > 0){

        addError("If you have Found one swords tile, please fill in the rest.")
    }

    if(mediumCount==4)
    {
        if(tryFitMedium(firstMedium.x,firstMedium.y,true)){
            mediumFound = true;
        }
        else
        {     
        addError("Please double check your chest/present position")
        }
        
    }

    if(swordCount==6){

        if(tryFitLongTall(firstSword.x,firstSword.y,true) || tryFitLongSide(firstSword.x,firstSword.y,true)){
            swordFound = true;
        }
        else{     
        addError("Please double check your swords position")
        }
    }

    if(mediumCount>4){
        addError("You have too many Medium tiles")
    }

    if(swordCount>6){        
        addError("You have too many Sword tiles")
    }

}

function clearErrors()
{
    byId('MessageSection').innerHTML = '';
}

function addError(errorText)
{
    hasErrors = true;
    var error, curRow;

    curRow = newEl('tr');
    error = newEl('text');
    error.innerHTML =  '<p>' + errorText + '</p>'

    curRow.appendChild(error);
    byId('MessageSection').appendChild(curRow);
}


function buildGrid()
{
    byId('tblTgt').innerHTML = '';


    var tbl, curRow, curCell;
    tbl = newEl('table');
    var x, y;
    for (y=0; y<nRows; y++)
    {
        curRow = newEl('tr');
        tbl.appendChild(curRow);

        for (x=0; x<nCols; x++)
        {


            grid[formatGridPosition(x,y)] = {
                x: x,
                y: y,
                type: unrevealed,
                value: 0
            }
            curCell = newEl('select');
            curCell.name = formatGridPosition(x,y)
            curCell.id = "select" + x + "/" + y
            curCell.addEventListener('change', onGridValueChanged, false);

            for (const val of values){
                var option = document.createElement("option");
                option.value = val.value;
                option.text = val.name;
                curCell.appendChild(option);
            }

            //curCell.innerText = "[" + x + "," + y + "]";
            curRow.appendChild(curCell);
        }
    }
    byId('tblTgt').appendChild(tbl);
}

</script>
<style>

</style>
</head>
<body>


    <div><table id='MessageSection'></table></div>
    <hr>
    <div id='tblTgt'></div>
    <hr>
    <div id='tblDebug'></div>

    <div id='instructions'>

        <h1>How to Use</h1>
        <ul>
            <li>Fill in all the metal tiles you can see in the grid above</li>
            <li>The tiles with the highest value (green) will Give you the most information</li>
            <li>When you find a piece of a larger image in game, fill in the grid above with the whole image</li>
            <li>If you can use your Retelling, when you find the swords Icon, reveal it</li>
            <li>If you cannot use your retelling or have fully revealed the swords, then search for the Medium tile</li>
            <li>If you can complete the medium tile with remaining reveals, do so</li>
            <li>If you cannot finish a larger tile, search for the chance of the Bonus tile (avoid spaces you know are parts of bigger tiles)</li>
        </ul>>
    </div>
</body>
</html>