<!DOCTYPE html>
<html>
<head>

<style>

select {
                width: 50px;
                height:50px;
            }

            input {
                width: 50px;
                height:50px;
            }

.container {
  display: flex;
  justify-content: center;
}


.bestMatch {
     background: green;
}
        
</style>
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">

<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV" crossorigin="anonymous"></script>
<script>
"use strict";
function byId(e){return document.getElementById(e);}
function newEl(tag){return document.createElement(tag);}

window.addEventListener('load', onDocLoaded, false);

var grid = {};

var unrevealed = 0;
var empty = -2;
var metal = -1;
var fox = 1;
var medium = 2;
var swords = 3;

var nCols = 6;
var nRows = 6;

var wantRetelling = false;

var swordFound = false;
var mediumFound = false;

var hasErrors = true;


var values = [
    {name:"Unrevealed",
    value: unrevealed},
    {name:"Empty",
    value: empty}
    ,
    {name:"Metal",
    value: metal}
    ,
    {name:"Fox",
    value: fox}
    ,
    {name:"Chest/Present",
    value: medium}
    ,
    {name:"Swords",
    value: swords}
]

function onDocLoaded()
{
init()
}

function init(){
    buildGrid();
    recalculateGrid();
}

function withinBounds(x,y)
{
if(x>=0 && y>=0 && x<=(nCols-1) && y<=(nRows-1)){
    return true
}
return false;
}

function canPlace(type, tile, onlyExactMatch){
    if (tile.type == type || (tile.type == unrevealed && !onlyExactMatch)){
        return true;
    }
    else
    {
        return false;
    }
}

function tryFitTiles(xStart,yStart){
    if(!mediumFound && tryFitMedium(xStart,yStart)){
        scoreMedium(xStart,yStart)
    }
    if(!swordFound){
        if(tryFitLongSide(xStart,yStart)){
            scoreLongSide(xStart,yStart);
        }
        if(tryFitLongTall(xStart,yStart)){
            scoreLongTall(xStart,yStart);
        }

    }
}


function tryFitMedium(xStart,yStart)
{
    return tryFitMedium(xStart,yStart,false)
}


function tryFitMedium(xStart,yStart,onlyExactMatch)
{
    return canFit(xStart,yStart,1,1,medium,onlyExactMatch)
}

function scoreMedium(xStart,yStart){
    addValueToTiles(xStart,yStart,1,1,4)
}


function tryFitLongSide(xStart,yStart)
{
    return tryFitLongSide(xStart,yStart,false)
}


function tryFitLongSide(xStart,yStart,onlyExactMatch)
{
    return canFit(xStart,yStart,2,1,swords,onlyExactMatch);
}

function scoreLongSide(xStart,yStart){
    
    addValueToTiles(xStart,yStart,2,1,6);
}

function tryFitLongTall(xStart,yStart)
{
    return tryFitLongTall(xStart,yStart,false);
}


function tryFitLongTall(xStart,yStart,onlyExactMatch)
{
    return canFit(xStart,yStart,1,2,swords,onlyExactMatch);
}

function scoreLongTall(xStart,yStart){
    addValueToTiles(xStart,yStart,1,2,6);
}



function canFit(xStart, yStart, xSize,ySize, type)
{
   return canFit(xStart, yStart, xSize,ySize, type, false)
}


function canFit(xStart, yStart, xSize,ySize, type, onlyExactMatch)
{
    var canPlaceTile = true;

    if(!withinBounds((xStart+xSize),(yStart+ySize))){
        return false;
    }

    var x, y;
    for (y=0; y<=ySize; y++)
    {

        for (x=0; x<=xSize; x++)
        {

            var currentXPos = xStart + x;
            var currentYPos =  yStart + y;
            
            var tile = grid[formatGridPosition(currentXPos,currentYPos)]
            
            canPlaceTile = canPlace(type,tile,onlyExactMatch);

            if(!canPlaceTile){
                return false;
            }
        }

    }  

    return canPlaceTile;
}

function addValueToTiles(xStart, yStart, xSize,ySize,valueToAdd)
{

    var x, y;
    for (y=0; y<=ySize; y++)
    {

        for (x=0; x<=xSize; x++)
        {

            var currentXPos = xStart + x;
            var currentYPos =  yStart + y;
            
            var tile = grid[formatGridPosition(currentXPos,currentYPos)]
            
           tile.value+= valueToAdd;
        }

    }  

}

function recalculateGrid(){
    clearGridValuesSection()
    validateGrid();

    if(!hasErrors){

    var x, y;
    for (y=0; y<nRows; y++)
    {
        for (x=0; x<nCols; x++)
        {
            tryFitTiles(x,y)
        }

    }

    buildGridValuesSection();

    hightlightHighestRows()
    }
}



function hightlightHighestRows(){
    
    var x, y, max;
    max = 0;
    for (y=0; y<nRows; y++)
    {
        for (x=0; x<nCols; x++)
        {
            var tile = grid[formatGridPosition(x,y)];
            if(tile.value>max){
                max = tile.value;
            }
        }

    }


    for (y=0; y<nRows; y++)
    {
        for (x=0; x<nCols; x++)
        {
            var tile = grid[formatGridPosition(x,y)];
            if(tile.value==max){
                byId("select"+formatGridPosition(x,y)).classList.add("bestMatch")
                byId("display"+formatGridPosition(x,y)).classList.add("bestMatch")
            }
        }

    }
}

function formatGridPosition(xpos,ypos){

return xpos + "/" + ypos;
}


function onGridValueChanged(evt)
{
    grid[this.name].type = this.value;

    recalculateGrid();
}


function clearGridValuesSection()
{
    byId('tblDebug').innerHTML = '';
}

function buildGridValuesSection()
{
    clearGridValuesSection();


    var tbl, curRow, curCell;
    tbl = newEl('table');
    var x, y;
    for (y=0; y<nRows; y++)
    {
        curRow = newEl('tr');
        tbl.appendChild(curRow);

        for (x=0; x<nCols; x++)
        {
            curCell = newEl('INPUT');
            curCell.setAttribute("id","display"+formatGridPosition(x,y))       
            curCell.setAttribute("type", "text");
            curCell.value =  grid[formatGridPosition(x,y)].value
            curRow.appendChild(curCell);
        }
    }
    byId('tblDebug').appendChild(tbl);
}


function validateGrid()
{
    clearErrors();
    //Reset values
    hasErrors = false;
    swordFound = false;
    mediumFound = false;


    var swordCount = 0;
    var mediumCount = 0;

    var firstSword;

    var firstMedium;

    var x, y;
    for (y=0; y<nRows; y++)
    {     

        for (x=0; x<nCols; x++)
        {
            var tile = grid[formatGridPosition(x,y)];
            if(tile.type == swords){
                if(!firstSword){
                    firstSword = tile;
                }
                swordCount++
            }else if(tile.type == medium){
                
                if(!firstMedium){
                    firstMedium = tile;
                }

                mediumCount++
            }

            byId("select"+formatGridPosition(x,y)).className = "";

            tile.value = 0;
        }
    }

    if(mediumCount<4 && mediumCount > 0){
        addError("If you have Found one medium tile, please fill in the rest.")
    }

    if(swordCount<6  && swordCount > 0){

        addError("If you have Found one swords tile, please fill in the rest.")
    }

    if(mediumCount==4)
    {
        if(tryFitMedium(firstMedium.x,firstMedium.y,true)){
            mediumFound = true;
        }
        else
        {     
        addError("Please double check your chest/present position")
        }
        
    }

    if(swordCount==6){

        if(tryFitLongTall(firstSword.x,firstSword.y,true) || tryFitLongSide(firstSword.x,firstSword.y,true)){
            swordFound = true;
        }
        else{     
        addError("Please double check your swords position")
        }
    }

    if(mediumCount>4){
        addError("You have too many Medium tiles")
    }

    if(swordCount>6){        
        addError("You have too many Sword tiles")
    }

}

function clearErrors()
{
    byId('MessageSection').innerHTML = '';
}

function addError(errorText)
{
    hasErrors = true;
    var error, curRow;

    curRow = newEl('tr');
    error = newEl('text');
    error.innerHTML =  '<p>' + errorText + '</p>'

    curRow.appendChild(error);
    byId('MessageSection').appendChild(curRow);
}


function buildGrid()
{
    byId('tblTgt').innerHTML = '';

    grid = {};
    var tbl, curRow, curCell;
    tbl = newEl('table');
    var x, y;
    for (y=0; y<nRows; y++)
    {
        curRow = newEl('tr');
        tbl.appendChild(curRow);

        for (x=0; x<nCols; x++)
        {


            grid[formatGridPosition(x,y)] = {
                x: x,
                y: y,
                type: unrevealed,
                value: 0
            }
            curCell = newEl('select');
            curCell.name = formatGridPosition(x,y)
            curCell.id = "select" + formatGridPosition(x,y)
            curCell.addEventListener('change', onGridValueChanged, false);

            for (const val of values){
                var option = document.createElement("option");
                option.value = val.value;
                option.text = val.name;
                curCell.appendChild(option);
            }

            //curCell.innerText = "[" + x + "," + y + "]";
            curRow.appendChild(curCell);
        }
    }
    byId('tblTgt').appendChild(tbl);
}

</script>
<style>

</style>
</head>
<body>


    <div class="container" ><table id='MessageSection'></table></div>
    <hr>
    
    <div id='tblTgt' class="container"></div>
    <div class="container" >
    <button onclick="init()">Reset</button>
</div>
    <hr>
    <div id='tblDebug' class="container" ></div>

    <div id='instructions' >
        <div class="container">
        <h1>How to Use</h1>
    </div>#
    <div class="container">
        <ul>
            <li>Fill in all the metal tiles you can see in the grid above</li>
            <li>The tiles with the highest value (Green) will Give you the most information</li>
            <li>When you find a piece of a larger image in game, fill in the grid above with the whole image</li>
            <li>If you can use your Retelling, when you find the swords Icon, reveal it</li>
            <li>If you cannot use your retelling or have fully revealed the swords, then search for the Medium tile</li>
            <li>If you can complete the medium tile with remaining reveals, do so</li>
            <li>If you cannot finish a larger tile, search for the chance of the Bonus tile (avoid spaces you know are parts of bigger tiles)</li>
        </ul>
    </div>

</div>
</body>
</html>